/*! \page api.dox HomePort API Specification
 *
 * \tableofcontents
 *
 * @startuml "A HomePort Executable"
 * node "Main Executable" {
 *     [Adapter] - [HomePort Library]
 *     [HomePort Library] - [Application]
 * }
 * @enduml
 *
 * In general, a HomePort installation consists of the HomePort library, one or more adapters and applications, and a
 * main program that combines everything into one executable.
 * - Adapter: A module that provides a connection to one or more devices.
 * - Application: A module that utilises this data, typically by providing an interface to a cloud.
 *
 * A conceptual architecture, that includes the internal components of the HomePort library:
 * \todo Outdated diagram, only included for reference.
 *
 * \image html hpd_concept_arch.png "Conceptual Architecture"
 *
 * \section sec_data_mode HomePort data model
 *
 * The model layer in HomePort remains consistent with previous version, and from the outside looks like this:
 *
 * @startuml "HomePort Data Model"
 * hide empty members
 * class hpd_t
 * class adapter_t
 * class device_t
 * class service_t
 * class parameter_t
 * hpd_t o-- adapter_t
 * adapter_t o-- device_t
 * device_t o-- service_t
 * service_t o-- parameter_t
 * @enduml
 *
 * The internal class diagram for reference, most but not all types are available to the outside through references
 * (direct access to members are generally not possible):
 *
 * \todo Class diagram is outdated, included as it is still roughly correct.
 *
 * @startuml "Class diagram (Probably outdated)"
 *
 * package daemon {
 *     class hpd {
 *         hpd_ev_loop_t *loop
 *         ev_signal sigint_watcher
 *         ev_signal sigterm_watcher
 *         int options_count
 *         argp_option_t *options
 *         hpd_module_t **option2module
 *     }
 *
 *     class hpd_module {
 *         char *id;
 *         void *data;
 *     }
 *
 *     class hpd_module_def {
 *         hpd_create_f on_create;
 *         hpd_destroy_f on_destroy;
 *         hpd_start_f on_start;
 *         hpd_stop_f on_stop;
 *         hpd_parse_opt_f on_parse_opt;
 *     }
 * }
 *
 * package data_structures {
 *     class hpd_pair {
 *         char *k
 *         char *v
 *     }
 * }
 *
 * package comm {
 *     class hpd_request {
 *         hpd_method_t method
 *         hpd_response_f on_response
 *         hpd_free_f on_free
 *         void *data
 *     }
 *
 *     class hpd_response {
 *         hpd_status_t status
 *     }
 *
 *     class hpd_value {
 *         char *body
 *         size_t len
 *     }
 * }
 *
 * package model {
 *     class configuration {
 *     }
 *     class hpd_adapter {
 *         hpd_free_f on_free;
 *         void *data;
 *     }
 *     class hpd_device {
 *         hpd_free_f on_free;
 *         void *data;
 *     }
 *     class hpd_service {
 *         hpd_free_f on_free
 *         void *data
 *     }
 *     class hpd_parameter {
 *     }
 *     class hpd_action {
 *         hpd_method_t method
 *         hpd_action_f action
 *     }
 * }
 *
 * hpd_request --> hpd_service
 * hpd_request --> hpd_value
 * hpd_response -> hpd_request
 * hpd_response -> hpd_value
 * hpd_value --> hpd_pair : headers
 * hpd "1" *-- "1" configuration
 * hpd "1" *-- "*" hpd_module
 * hpd_module "1" *-- "1" hpd_module_def
 * configuration "1" *-- "*" hpd_adapter
 * configuration "1" *-- "*" hpd_listener
 * hpd_adapter "1" *-- "*" hpd_device
 * hpd_adapter "1" *-- "*" hpd_listener
 * hpd_adapter --> "*" hpd_pair : attributes
 * hpd_device "1" *-- "*" hpd_service
 * hpd_device "1" *-- "*" hpd_listener
 * hpd_device --> "*" hpd_pair : attributes
 * hpd_service "1" *-- "*" hpd_parameter
 * hpd_service "1" *-- "*" hpd_listener
 * hpd_service --> "*" hpd_pair : attributes
 * hpd_service --> "*" hpd_action
 * hpd_parameter --> hpd_pair : attributes
 *
 * class hpd_listener {
 *     enum {} type
 *     hpd_value_f on_change
 *     hpd_device_f on_attach
 *     hpd_device_f on_detach
 *     void *data
 *     hpd_free_f on_free
 * }
 *
 * @enduml
 *
 * \subsection sec_error_handling Enumerations for error handling
 *
 * All functions in the API returns hpd_err_t, which is:
 * \todo Should really reconsider whether to have errors on free functions - really difficult to handle (there's a reason you're not suppose to throw in destructors!)
 *
 * \snippet include/hpd_types.h hpd_error_t
 *
 * For the request-response relationships HomePort continues to use HTTP status codes to describe errors, as many
 * modules relies on HTTP connections. From the HTTP protocol, these are:
 *
 * \snippet include/hpd_types.h hpd_status_t
 *
 * \subsection sec_attrs Attribute default keys
 *
 * The entities in the data model are described using attributes. These are flexible key-value pairs, where the keys can
 * be chosen freely. However, we do define the following default keys for consistencies between modules:
 * \todo As with default keys, we could add default values as well; Type = Temperature, Unit = C, etc. Seluxit and Zigbee can be used for inspiration (Rene’s work).
 *
 * \snippet include/hpd_types.h Default keys
 *
 * \subsection sec_methods Method enumeration
 *
 * Services have a set of actions, currently for get and put only, but these are define in a enumeration, thus can
 * easily be expanded later:
 *
 * \snippet include/hpd_types.h hpd_method_t
 *
 * \subsection sec_custom_data Custom user data and free functions
 *
 * HomePort's data model allow module developers to store custom pointers to user data of their own choice. HomePort
 * will not touch this data. To allow memory management of custom data pointers, HomePort generally take a on_free
 * callback function with the data pointer. This function will be called when HomePort is free'ing the object and can be
 * used by the module developer to ensure that the custom data is free'd as well. The function pointer can be NULL, if
 * it is not necessary to free the data.
 *
 * \snippet include/hpd_types.h hpd_free_f
 *
 * \section sec_main Daemon API
 *
 * \snippet include/hpd_daemon_api.h hpd_t functions
 *
 * First, the main program allocates memory for HomePort (hpd_t) with hpd_alloc(). Then it tells HomePort of all
 * modules that it wishes to include with hpd_module(). We shall use the term module for both adapters and applications.
 * All modules are assigned a unique id by the main program, which allows running multiple instances of the same module.
 * module_def is a public structure, of which each module should provide an instance (explained below).
 *
 * @startuml "Main program"
 *
 * participant "main()" as Main
 * participant Daemon
 * entity hpd_t
 *
 * [->Main
 * activate Main
 * Main -> Daemon: hpd_alloc()
 * activate Daemon
 * Daemon -> hpd_t: alloc()
 * activate hpd_t
 * Main <-- Daemon
 * deactivate Daemon
 * Main -> Daemon: hpd_module()
 * activate Daemon
 * Main <-- Daemon
 * deactivate Daemon
 * Main -> Daemon: hpd_start()
 * activate Daemon
 * ...Running...
 * [-> Daemon: hpd_stop()
 * activate Daemon
 * [<-- Daemon
 * deactivate Daemon
 * Main <-- Daemon
 * deactivate Daemon
 * Main  -> Daemon: hpd_free()
 * activate Daemon
 * Daemon -> hpd_t: free()
 * destroy hpd_t
 * Main <-- Daemon
 * deactivate Daemon
 * [<-- Main
 * deactivate Main
 * @enduml
 *
 * The main program will then start HomePort with hpd_start(). Note that this function does not return, but will keep
 * running until hpd_stop() is called. hpd_stop() will be called automatically on sigint and sigterm. Finally, the main
 * program will deallocate the memory with hpd_free().
 *
 * Any pointer to hpd_t is valid between calls to hpd_alloc() and hpd_free(), and thus can generally be stored by
 * modules in their entire lifetime.
 *
 * \section sec_shared_api Shared API (Adapters and Applications) - Part I
 *
 * \subsection sec_modules Modules
 *
 * A module will provide an instance of the module_def structure along with implementations of the five included
 * functions. module_def is a structure where the members are publicly available.
 *
 * \snippet include/hpd_types.h hpd_module_def_t
 *
 * The five functions:
 * \snippet include/hpd_types.h hpd_module_def_t functions
 *
 * In here, on_create and on_destroy are used to allocate/deallocate globally available memory in data, which can be
 * used freely. on_start and on_stop are used to initialise/stop the underlying connection and add watchers to the event
 * loop – whatever is required for the module to be considered running. To handle program argument given to the
 * executable, a module can also define on_parse_opt, which may be called between on_create and on_start due to
 * arguments given to the executable.
 *
 * @startuml "Module functions and object lifetime"
 *
 * participant Daemon
 * participant Module
 * entity hpd_module_t
 * entity hpd_loop_t
 *
 * [-> Daemon: hpd_alloc()
 * activate Daemon
 * [<-- Daemon
 * deactivate Daemon
 * [-> Daemon: hpd_module()
 * activate Daemon
 * Daemon -> hpd_module_t: alloc()
 * activate hpd_module_t
 * [<-- Daemon
 * deactivate Daemon
 * [-> Daemon: hpd_start()
 * activate Daemon
 * Daemon -> Module: on_create()
 * activate Module
 * Module -> Daemon: hpd_module_get_id()
 * activate Daemon
 * Module <-- Daemon
 * deactivate Daemon
 * Module -> Daemon: hpd_module_add_option()
 * activate Daemon
 * Module <-- Daemon
 * deactivate Daemon
 * Daemon <-- Module
 * deactivate Module
 * Daemon -> Module: on_parse_opt()
 * activate Module
 * Daemon <-- Module
 * deactivate Module
 * Daemon -> hpd_loop_t: ev_loop_new()
 * activate hpd_loop_t
 * Daemon -> Module: on_start()
 * activate Module
 * Module -> Daemon: hpd_get_loop()
 * activate Daemon
 * Module <-- Daemon
 * deactivate Daemon
 * Daemon <-- Module
 * deactivate Module
 * ...Running...
 * [-> Daemon: hpd_stop()
 * activate Daemon
 * [<-- Daemon
 * deactivate Daemon
 * Daemon -> Module: on_stop()
 * activate Module
 * Daemon <-- Module
 * deactivate Module
 * Daemon -> hpd_loop_t: ev_loop_destroy()
 * destroy hpd_loop_t
 * Daemon -> Module: on_destroy()
 * activate Module
 * Daemon <-- Module
 * deactivate Module
 * [<-- Daemon
 * deactivate Daemon
 * [-> Daemon: hpd_free()
 * activate Daemon
 * Daemon -> hpd_module_t: free()
 * destroy hpd_module_t
 * [<-- Daemon
 * deactivate Daemon
 * @enduml
 *
 * The following three functions are shared between adapters and applications:
 * \snippet include/hpd_shared_api.h hpd_t functions
 *
 * For arguments to work, the module will have to add any options using hpd_module_add_option() during on_create.
 * Options will be named --id-name, where id is the module identifier, as given by the main program. The module can call
 * hpd_module_get_id() to obtain this id. During on_start and afterwards, the event loop will be accessible through
 * hpd_get_loop(). On here, the module can put io-watchers, timer-watchers, and more to trigger on events.
 *
 * A module can rely on the pointer to its hpd_module_t (as given in on_create()) will be valid for its entire lifetime,
 * that is between calls to on_create and on_destroy. The pointer to its id (as obtained with hpd_module_get_id()) is
 * valid in the same interval. The pointer to the event loop (as obtained with hpd_get_loop()) is valid between calls to
 * on_start and on_stop.
 *
 * \subsection sec_indirect_refs Indirect references
 *
 * Through the following sections we shall utilise indirect references to objects in the data mode (adapters, devices,
 * services, parameters). These prevent module developers from keeping pointers to objects that eventually will be
 * free'd, thus making these pointers invalid. To allocate and free these references:
 *
 * \snippet include/hpd_shared_api.h id_t functions
 *
 * If a module developers explicitly call *_id_alloc(), they are also responsible for calling *_id_free().
 *
 * \section sec_adapter_api Adapter API
 *
 * The functions in the Adapter API are only available for adapters.
 *
 * \subsection sec_hpd_adapter_t Adapter structure (hpd_adapter_t)
 *
 * To maintain adapter structures in the data model:
 * \todo Maybe change name of the structure from “adapter” to “network” to highlight the differences between modules and adapters. A module can make multiple networks of devices.
 *
 * \snippet include/hpd_adapter_api.h hpd_adapter_t functions
 *
 * alloc/free are used to manage memory. attach/detach are used to hand the object to HomePort. If an object is
 * attached, it will be visibly through the navigation functions (shown later) and HomePort will ensure that the memory
 * is managed. For example this means that if an adapter is freed, all devices, services, etc. below it will
 * automatically be freed also. Note that the reverse applies too; if an object is detached, HomePort do not know about
 * it and it is up to the module to manage the memory. set_data/get_data functions can be used, by the adapter, to
 * store custom data within HomePort. If on_free is set, HomePort will call this function to free this custom data,
 * when the object is freed.
 *
 * As to when to use a direct pointer to the adapter and when to use an indirect reference, see the following diagram.
 * hpd_adapter_alloc() allocates the instance of hpd_adapter_t, which is referred to using a pointer - the module
 * developer is in control of the memory. The object is changed (set functions), and finally hpd_adapter_attach() is
 * called. After this call the pointer _will_ be invalid and we can only refer to the object using instances of
 * hpd_adapter_id_t (indirect references) - HomePort manages the memory.
 *
 * @startuml "Lifetime of adapter structures (Outside view, not exact implementation)"
 *
 * participant Module
 * participant Discovery
 * entity hpd_adapter_t
 * entity hpd_adapter_id_t
 *
 * [-> Module
 * activate Module
 *
 * Module -> Discovery: hpd_adapter_alloc()
 * activate Discovery
 * Discovery -> hpd_adapter_t: alloc()
 * activate hpd_adapter_t
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_set_data()
 * activate Discovery
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_set_attr()
 * activate Discovery
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_set_attrs()
 * activate Discovery
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_attach()
 * activate Discovery
 * Discovery -> hpd_adapter_t: move()
 * destroy hpd_adapter_t
 * Module <-- Discovery
 * deactivate Discovery
 *
 * [<-- Module
 * deactivate Module
 *
 * ...
 *
 * [-> Module
 * activate Module
 *
 * Module -> Discovery: hpd_adapter_id_alloc()
 * activate Discovery
 * Discovery -> hpd_adapter_id_t: alloc()
 * activate hpd_adapter_id_t
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_get_data()
 * activate Discovery
 * Module <-- Discovery
 * deactivate Discovery
 *
 * ...
 *
 * Module -> Discovery: hpd_adapter_detach()
 * activate Discovery
 * Discovery -> hpd_adapter_t: alloc()
 * activate hpd_adapter_t
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_free()
 * activate Discovery
 * Discovery -> hpd_adapter_t: free()
 * destroy hpd_adapter_t
 * Module <-- Discovery
 * deactivate Discovery
 *
 * Module -> Discovery: hpd_adapter_id_free()
 * activate Discovery
 * Discovery -> hpd_adapter_id_t: free()
 * destroy hpd_adapter_id_t
 * Module <-- Discovery
 * deactivate Discovery
 *
 * [<-- Module
 * deactivate Module
 *
 * @enduml
 *
 * After a call to hpd_adapter_detach(), the indirect reference will still be allocated, but will now result in
 * HPD_E_NOT_FOUND, if we try to use it. hpd_adapter_detach() also returns a pointer to hpd_adapter_t -- it is now
 * the responsibility of the module to free the object.
 *
 * \par Implementation details:
 * hpd_adapter_attach() will make a copy of hpd_adapter_t, thus effectively invalidating the pointer.
 * hpd_adapter_detach() will return a pointer to this copy, which was stored in the internal data model.
 *
 * \subsection sec_hpd_device_t Device structure (hpd_device_t)
 *
 * Devices are managed in a similar manner:
 * \snippet include/hpd_adapter_api.h hpd_device_t functions
 *
 * \subsection sec_hpd_service_t Service structure (hpd_service_t)
 *
 * Services furthermore allow setting an action, which is a method and a function pointer. Currently only get and put
 * is support, but it could theoretically be expanded to others:
 * \snippet include/hpd_adapter_api.h hpd_service_t functions
 * \snippet include/hpd_types.h hpd_action_f
 *
 * \subsection sec_hpd_parameter_t Parameter structure (hpd_parameter_t)
 *
 * Finally, functions to manage parameters:
 * \snippet include/hpd_adapter_api.h hpd_parameter_t functions
 *
 * \section sec_shared_api_cont Shared API (Adapters and Applications) - Part II
 *
 * \subsection sec_data_model_get Data model getters
 *
 * To get members from the objects, created by an adapter, applications have the following functions:
 * \snippet include/hpd_shared_api.h hpd_adapter_t functions
 * \snippet include/hpd_shared_api.h hpd_device_t functions
 * \snippet include/hpd_shared_api.h hpd_service_t functions
 * \snippet include/hpd_shared_api.h hpd_action_t functions
 * \snippet include/hpd_shared_api.h hpd_parameter_t functions
 *
 * Again, we have a define to ease foreach loops:
 * \snippet include/hpd_shared_api.h hpd_service_t foreach loops
 *
 * \subsection sec_data_model_nav Data model navigation
 *
 * The HomePort data model can be navigated by both adapters and applications, thus only the later will find use for
 * browsing through models created by another module. To do so, the following functions are available:
 * \snippet include/hpd_shared_api.h Browsing functions
 *
 * In brief: Get functions will navigate upwards in the hierarchy, first functions will get the first object in the list
 * under the given object, next will give the next one, and the find functions are used to find objects based on
 * attributes. The arguments given to a find function is key-value pairs, and the attributes of an object must match all
 * the given attributes (e.g. strcmp == 0) for an object to be found, attributes whose key is not given as attribute are
 * not considered. A find function will give the first object to match, where a find next function will give the next
 * matching object.
 *
 * Because first-next function are a bit complicated to use, the following defines are also available to create simple
 * foreach loops (based on the same principle from libev):
 * \snippet include/hpd_shared_api.h Browsing foreach loops
 *
 * \section sec_comm Communication
 *
 * \subsection sec_value Shared API - Value structure
 *
 * The value structure is used in both get and put requests and thus is available for both adapters and applications:
 * \snippet include/hpd_shared_api.h hpd_value_t functions
 * \snippet include/hpd_shared_api.h hpd_value_t foreach loops
 *
 * The body of a value is the actual value, where the headers are additional attributes, which are currently unused but
 * will be used to indicate time-to-live for caching, but are defined generic so they can easily be expanded without
 * breaking the API. Note it is also possible for adapters and applications to store their own custom headers, similar
 * to the principle in HTTP headers.
 *
 * The len in hpd_value_alloc can be set to HPD_NULL_TERMINATED if body is a \\0 terminated string:
 *
 * \snippet include/hpd_types.h HPD_NULL_TERMINATED
 *
 * \subsection sec_adapter_comm Adapter API - Communication
 *
 * Action functions will need functions related to requests/responses to manage these (functions to manage values are
 * shared with applications and will be shown later):
 * \snippet include/hpd_adapter_api.h hpd_request_t functions
 * \snippet include/hpd_adapter_api.h hpd_response_t functions
 *
 * And when, we are considering communication, an adapter should call the following function, whenever a service has
 * changed value:
 * \snippet include/hpd_adapter_api.h hpd_changed
 *
 * @startuml "Lifetime of request/response structures"
 *
 * participant Adapter as adp
 * participant "Request\nDispatch" as req
 * participant "Value" as val
 * entity "Request\nhpd_value_t" as req_val
 * entity "hpd_request_t" as req_t
 * entity "Response\nhpd_value_t" as res_val
 * entity "hpd_response_t" as res_t
 *
 * [-> req
 * activate req_val
 * activate req_t
 * activate req
 *
 * req -> adp: on_action()
 * activate adp
 *
 * adp -> req: hpd_request_get_service()
 * activate req
 * adp <-- req
 * deactivate req
 *
 * adp -> req: hpd_request_get_method()
 * activate req
 * adp <-- req
 * deactivate req
 *
 * adp -> req: hpd_request_get_value()
 * activate req
 * adp <-- req
 * deactivate req
 *
 * adp -> val: hpd_value_get_body()
 * activate val
 * adp <-- val
 * deactivate val
 *
 * adp -> val: hpd_value_get_header()
 * activate val
 * adp <-- val
 * deactivate val
 *
 * req <-- adp
 * deactivate adp
 *
 * [<-- req
 * deactivate req
 *
 * ... Later ...
 *
 * [-> adp
 * activate adp
 *
 * adp -> val: hpd_value_alloc()
 * activate val
 * val -> res_val: alloc()
 * activate res_val
 * adp <-- val
 * deactivate val
 *
 * adp -> val: hpd_value_set_header()
 * activate val
 * adp <-- val
 * deactivate val
 *
 * adp -> req: hpd_response_alloc()
 * activate req
 * req -> res_t: alloc()
 * activate res_t
 * req -> req_val: move()
 * destroy req_val
 * req -> req_t: move()
 * destroy req_t
 * adp <-- req
 * deactivate req
 *
 * adp -> req: hpd_response_set_value()
 * activate req
 * req -> res_val: move()
 * destroy res_val
 * adp <-- req
 * deactivate req
 *
 * adp -> req: hpd_respond()
 * activate req
 * req -> res_t: move()
 * destroy res_t
 * adp <-- req
 * deactivate req
 *
 * [<-- adp
 * deactivate adp
 *
 * @enduml
 *
 * \subsection sec_application_api Application API - Communication
 *
 * The functions in the Application API are only available for applications.
 *
 * For hpd_request_t, hpd_response_t and hpd_listener_t functions we need the following callbacks:
 * \snippet include/hpd_types.h Application API Callbacks
 *
 * The functions for requests and response are the reverse of an adapter (an application can create requests and read
 * the values of a response):
 * \snippet include/hpd_application_api.h hpd_request_t functions
 * \snippet include/hpd_application_api.h hpd_response_t functions
 *
 * In addition, an application can also create listeners. Listeners can be created on any object (HomePort, adapter,
 * device, and service) and will be called for that object and everything below if the conditions are met. E.g., a
 * listener with a value callback on an adapter will be called if any service under that adapter changes value. Function
 * to manage listeners:
 * \snippet include/hpd_application_api.h hpd_listener_t functions
 *
 * The foreach function will cause the given listener to be called for each device that is already attached.
 *
 * @startuml "Lifetime of request/response structures"
 *
 * participant Application as app
 * participant Discovery as dis
 * participant "Request\nDispatch" as req
 * participant "Value" as val
 * entity "hpd_service_id_t" as sid
 * entity "Request\nhpd_value_t" as req_val
 * entity "hpd_request_t" as req_t
 * entity "Response\nhpd_value_t" as res_val
 * entity "hpd_response_t" as res_t
 *
 * [-> app
 * activate app
 *
 * app -> dis: hpd_service_id_alloc()
 * activate dis
 * dis -> sid: alloc()
 * activate sid
 * app <-- dis
 * deactivate dis
 *
 * app -> req: hpd_request_alloc()
 * activate req
 * req -> req_t: alloc()
 * activate req_t
 * req -> sid: copy()
 * app <-- req
 * deactivate req
 *
 * app -> dis: hpd_service_id_free()
 * activate dis
 * dis -> sid: free()
 * destroy sid
 * app <-- dis
 * deactivate dis
 *
 * app -> val: hpd_value_alloc()
 * activate val
 * val -> req_val: alloc()
 * activate req_val
 * app <-- val
 * deactivate val
 *
 * app -> val: hpd_value_set_header()
 * activate val
 * app <-- val
 * deactivate val
 *
 * app -> req: hpd_request_set_value()
 * activate req
 * req -> req_val: move()
 * destroy req_val
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_request_set_data()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_request()
 * activate req
 * req -> req_t: move()
 * destroy req_t
 * app <-- req
 * deactivate req
 *
 * [<-- app
 * deactivate app
 *
 * ... Later ...
 *
 * [-> req
 * activate req_val
 * activate req_t
 * activate res_val
 * activate res_t
 * activate req
 *
 * req -> app: on_response()
 * activate app
 *
 * app -> req: hpd_response_get_status()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_response_get_request_data()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_response_get_request_service()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_response_get_request_method()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_response_get_request_value()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> req: hpd_response_get_value()
 * activate req
 * app <-- req
 * deactivate req
 *
 * app -> val: hpd_value_get_body()
 * activate val
 * app <-- val
 * deactivate val
 *
 * app -> val: hpd_value_get_header()
 * activate val
 * app <-- val
 * deactivate val
 *
 * req <-- app
 * deactivate app
 *
 * req -> req_val: free()
 * destroy req_val
 * req -> req_t: free()
 * destroy req_t
 * req -> res_val: free()
 * destroy res_val
 * req -> res_t: free()
 * destroy res_t
 *
 * [<-- req
 * deactivate req
 *
 * @enduml
 *
 */

// Module -> Discovery: hpd_adapter_alloc()